package devsearch.ast

import scala.reflect._

import shapeless._
import shapeless.poly._
import shapeless.ops.hlist._
import shapeless.UnaryTCConstraint._
import shapeless.LUBConstraint._

import Empty._

object Operators {

  /**
   * Typical foldRight function on tree structures. The function receives the results of being applied on
   * all the trees children as a second parameter.
   *
   * Mostly used to implement other utility functions such as [[exists]] and [[collect]].
   */
  def foldRight[T](f: (AST, Seq[T]) => T)(ast: AST): T = {
    val rec = foldRight(f) _

    val (children, _) = unapply(ast)
    f(ast, children.view.map(rec))
  }

  /** Test for existence of an AST node that satisfies `matcher` in `ast`. */
  def exists(matcher: AST => Boolean)(ast: AST): Boolean =
    foldRight[Boolean]((ast, subs) => matcher(ast) || subs.contains(true))(ast)

  /** Collects all instances generated by `matcher` during a full tree traversal. */
  def collect[T](matcher: AST => Set[T])(ast: AST): Set[T] =
    foldRight[Set[T]]((ast, subs) => matcher(ast) ++ subs.foldLeft(Set.empty[T])(_ ++ _))(ast)

  /**
   * Post-transform of `f` on `ast`. The optional argument `applyRec` can be used to perform
   * a transformation fixpoint over transformation results (but be careful this could ne non-terminating!)
   */
  def postMap(f: AST => Option[AST], applyRec: Boolean = false)(ast: AST): AST = {
    val rec = postMap(f, applyRec) _

    val newAST = {
      val (children, builder) = unapply(ast)
      val newChildren = children.map(rec)

      if ((children zip newChildren).exists { case (c, nc) => c ne nc }) {
        builder(newChildren)
      } else {
        ast
      }
    }

    if (applyRec) {
      fixpoint { ast: AST => f(ast) getOrElse ast } (newAST)
    } else {
      f(newAST) getOrElse newAST
    }
  }

  /** Helper function that performs fixpoint over a homomorphic function */
  def fixpoint[T](f: T => T, limit: Int = -1)(e: T): T = {
    var v1 = e
    var v2 = f(v1)
    var lim = limit
    while(v2 != v1 && lim != 0) {
      v1 = v2
      lim -= 1
      v2 = f(v2)
    }
    v2
  }

  /**
   * Children extractor
   *
   * This function returns the flattened list of the direct children of any AST. It also returns a function that can
   * rebuild the AST given a transformed list of children. Note that the transformed list MUST preserve types and size!
   *
   * This function is used as a building block for transformations and traversal.
   */
  def unapply(ast: AST): (List[AST], List[AST] => AST) = {

    case class ASTS[A : ClassTag](list: List[A]) {
      val tag = classTag[A]
      def size = list.size
    }

    trait Split[In <: HList] extends DepFn2[In, List[AST]] { type Out <: HList }

    object Split {
      def apply[L <: HList](implicit split: Split[L]): Aux[L, split.Out] = split
      type Aux[L <: HList, Out0 <: HList] = Split[L] { type Out = Out0 }

      implicit def hnilSplit: Aux[HNil, HNil] = new Split[HNil] {
        type Out = HNil
        def apply(l: HNil, asts: List[AST]): Out = HNil
      }

      implicit def hlistSplit[A, InT <: HList](implicit split: Split[InT]): Aux[ASTS[A] :: InT, List[A] :: split.Out] = new Split[ASTS[A] :: InT] {
        type Out = List[A] :: split.Out
        def apply(l: ASTS[A] :: InT, asts: List[AST]): Out = {
          val (headAsts, tailAsts) = asts.splitAt(l.head.size)
          headAsts.map(l.head.tag.unapply(_).get) :: split(l.tail, tailAsts)
        }
      }
    }

    def splits[L <: HList](asts: List[AST], sizes: L)(implicit ev: Split[L]): ev.Out = ev(sizes, asts)

    import Split._

    ast match {
      // -- Definitions ---------

      case PackageDef(name /*String*/, annotations /*List[Annotation]*/, imports /*List[Import]*/, definitions /*List[Definition]*/) =>
        val sizes = ASTS(annotations) :: ASTS(imports) :: ASTS(definitions) :: HNil
        (annotations ++ imports ++ definitions, asts => {
          splits(asts, HNil : HNil)(hnilSplit)
          val newAnnots :: newImports :: newDefs :: HNil = splits(asts, sizes)
          PackageDef(name, newAnnots, newImports, newDefs).fromAST(ast)
        })

      case TypeDef(modifiers /*Modifiers*/, name /*String*/, annotations /*List[Annotation]*/, tparams /*List[TypeDef]*/,
                   lowerBounds /*List[Type]*/, superBounds /*List[Type]*/) =>
        val sizes = ASTS(annotations) :: ASTS(tparams) :: ASTS(lowerBounds) :: ASTS(superBounds) :: HNil
        (annotations ++ tparams ++ lowerBounds ++ superBounds, asts => {
          val newAnnots :: newTParams :: newLowers :: newSupers :: HNil = splits(asts, sizes)
          TypeDef(modifiers, name, newAnnots, newTParams, newLowers, newSupers).fromAST(ast)
        })

      case ClassDef(modifiers /*Modifiers*/, name /*String*/, annotations /*List[Annotation]*/, tparams /*List[TypeDef]*/,
                    superClasses /*List[ClassType]*/, definitions /*List[Definition]*/, sort /*StructuralSort*/) =>
        val sizes = ASTS(annotations) :: ASTS(tparams) :: ASTS(superClasses) :: ASTS(definitions) :: HNil
        (annotations ++ tparams ++ superClasses ++ definitions, asts => {
          val newAnnots :: newTParams :: newSupers :: newDefs :: HNil = splits(asts, sizes)
          ClassDef(modifiers, name, newAnnots, newTParams, newSupers, newDefs, sort).fromAST(ast)
        })

      case EnumDef(modifiers /*Modifiers*/, name /*String*/, annotations /*List[Annotation]*/, superTraits /*List[ClassType]*/,
                   definitions /*List[Definition]*/, entries /*List[EnumConstantDef]*/) =>
        val sizes = ASTS(annotations) :: ASTS(superTraits) :: ASTS(definitions) :: ASTS(entries) :: HNil
        (annotations ++ superTraits ++ definitions ++ entries, asts => {
          val newAnnots :: newSupers :: newDefs :: newEntries :: HNil = splits(asts, sizes)
          EnumDef(modifiers, name, newAnnots, newSupers, newDefs, newEntries).fromAST(ast)
        })

      case EnumConstantDef(name /*String*/, annotations /*List[Annotation]*/, args /*List[Expr]*/, members /*List[Definition]*/) =>
        val sizes = ASTS(annotations) :: ASTS(args) :: ASTS(members) :: HNil
        (annotations ++ args ++ members, asts => {
          val newAnnots :: newArgs :: newMembers :: HNil = splits(asts, sizes)
          EnumConstantDef(name, newAnnots, newArgs, newMembers).fromAST(ast)
        })

      case AnnotationDef(modifiers /*Modifiers*/, name /*String*/, annotations /*List[Annotation]*/, members /*List[Definition]*/) =>
        val sizes = ASTS(annotations) :: ASTS(members) :: HNil
        (annotations ++ members, asts => {
          val newAnnots :: newMembers :: HNil = splits(asts, sizes)
          AnnotationDef(modifiers, name, newAnnots, newMembers).fromAST(ast)
        })

      case ConstructorDef(modifiers /*Modifiers*/, annotations /*List[Annotation]*/, tparams /*List[TypeDef]*/,
                          params /*List[ValDef]*/, body /*Block*/, isDestructor /*Boolean*/) =>
        val sizes = ASTS(annotations) :: ASTS(tparams) :: ASTS(params) :: ASTS(body :: Nil) :: HNil
        (annotations ++ tparams ++ params :+ body, asts => {
          val newAnnots :: newTParams :: newParams :: List(newBody) :: HNil = splits(asts, sizes)
          ConstructorDef(modifiers, newAnnots, newTParams, newParams, newBody, isDestructor).fromAST(ast)
        })

      case FunctionDef(modifiers /*Modifiers*/, name /*String*/, annotations /*List[Annotation]*/, tparams /*List[TypeDef]*/,
                       params /*List[ValDef]*/, tpe /*Type*/, body /*Block*/) =>
        val sizes = ASTS(annotations) :: ASTS(tparams) :: ASTS(params) :: ASTS(tpe :: Nil) :: ASTS(body :: Nil) :: HNil
        (annotations ++ tparams ++ params :+ tpe :+ body, asts => {
          val newAnnots :: newTParams :: newParams :: List(newTpe) :: List(newBody) :: HNil = splits(asts, sizes)
          FunctionDef(modifiers, name, newAnnots, newTParams, newParams, newTpe, newBody).fromAST(ast)
        })

      case ValDef(modifiers /*Modifiers*/, name /*String*/, annotations /*List[Annotation]*/, tpe /*Type*/, rhs /*Expr*/, varArgs /*Boolean*/) =>
        val sizes = ASTS(annotations) :: ASTS(tpe :: Nil) :: ASTS(rhs :: Nil) :: HNil
        (annotations :+ tpe :+ rhs, asts => {
          val newAnnots :: List(newTpe) :: List(newRhs) :: HNil = splits(asts, sizes)
          ValDef(modifiers, name, newAnnots, newTpe, newRhs, varArgs).fromAST(ast)
        })

      case ExtractionValDef(modifiers /*Modifiers*/, pattern /*Expr*/, annotations /*List[Annotation]*/, rhs /*Expr*/) =>
        val sizes = ASTS(pattern :: Nil) :: ASTS(annotations) :: ASTS(rhs :: Nil) :: HNil
        ((pattern +: annotations) :+ rhs, asts => {
          val List(newPattern) :: newAnnotations :: List(newRhs) :: HNil = splits(asts, sizes)
          ExtractionValDef(modifiers, newPattern, newAnnotations, newRhs).fromAST(ast)
        })

      case Initializer(isStatic /*Boolean*/, annotations /*List[Annotation]*/, body /*Block*/) =>
        val sizes = ASTS(annotations) :: ASTS(List(body)) :: HNil
        (annotations :+ body, asts => {
          val newAnnots :: List(newBody) :: HNil = splits(asts, sizes)
          Initializer(isStatic, newAnnots, newBody).fromAST(ast)
        })

      // -- Statements ----------

      case Import(name /*String*/, asterisk /*Boolean*/, static /*Boolean*/) => (Nil, asts => ast)

      case ThisCall(tpe /*Type*/, tparams /*List[Type]*/, args /*List[Expr]*/) =>
        val sizes = ASTS(tpe :: Nil) :: ASTS(tparams) :: ASTS(args) :: HNil
        ((tpe +: tparams) ++ args, asts => {
          val List(newTpe) :: newTParams :: newArgs :: HNil = splits(asts, sizes)
          ThisCall(newTpe, newTParams, newArgs).fromAST(ast)
        })

      case SuperCall(tpe /*Type*/, tparams /*List[Type]*/, args /*List[Expr]*/) =>
        val sizes = ASTS(tpe :: Nil) :: ASTS(tparams) :: ASTS(args) :: HNil
        ((tpe +: tparams) ++ args, asts => {
          val List(newTpe) :: newTParams :: newArgs :: HNil = splits(asts, sizes)
          SuperCall(newTpe, newTParams, newArgs).fromAST(ast)
        })

      case Assert(condition /*Expr*/, message /*Expr*/) =>
        (condition :: message :: Nil, asts => Assert(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Expr]).fromAST(ast))

      case Block(statements /*List[Statement]*/) =>
        (statements, asts => Block(asts.map(_.asInstanceOf[Statement])).fromAST(ast))

      case Return(value /*Expr*/) =>
        (value :: Nil, asts => Return(asts(0).asInstanceOf[Expr]).fromAST(ast))

      case NamedStatement(name /*String*/, statement /*Statement*/) =>
        (statement :: Nil, asts => NamedStatement(name, asts(0).asInstanceOf[Statement]).fromAST(ast))

      case Break(target /*Option[String]*/) => (Nil, asts => ast)

      case Continue(target /*Option[String]*/) => (Nil, asts => ast)

      case While(condition /*Expr*/, body /*Statement*/) =>
        (condition :: body :: Nil, asts => While(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Statement]).fromAST(ast))

      case Do(condition /*Expr*/, body /*Statement*/) =>
        (condition :: body :: Nil, asts => Do(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Statement]).fromAST(ast))

      case For(vals /*List[ValDef]*/, inits /*List[Expr]*/, condition /*Expr*/, updates /*List[Expr]*/, body /*Statement*/) =>
        val sizes = ASTS(vals) :: ASTS(inits) :: ASTS(condition :: Nil) :: ASTS(updates) :: ASTS(body :: Nil) :: HNil
        ((vals ++ inits :+ condition) ++ updates :+ body, asts => {
          val newVals :: newInits :: List(newCond) :: newUpdates :: List(newBody) :: HNil = splits(asts, sizes)
          For(newVals, newInits, newCond, newUpdates, newBody).fromAST(ast)
        })

      case Synchronize(lock /*Expr*/, body /*Statement*/) =>
        (lock :: body :: Nil, asts => Synchronize(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Statement]).fromAST(ast))

      // -- Types ---------------

      case ClassType(scope /*Expr*/, name /*String*/, annotations /*List[Annotation]*/, tparams /*List[Type]*/) =>
        val sizes = ASTS(scope :: Nil) :: ASTS(annotations) :: ASTS(tparams) :: HNil
        ((scope +: annotations) ++ tparams, asts => {
          val List(newScope) :: newAnnotations :: newTParams :: HNil = splits(asts, sizes)
          ClassType(newScope, name, newAnnotations, newTParams).fromAST(ast)
        })

      case ArrayType(base /*Type*/) =>
        (base :: Nil, asts => ArrayType(asts(0).asInstanceOf[Type]).fromAST(ast))

      case FunctionType(from /*List[Type]*/, to /*Type*/) =>
        (from :+ to, asts => FunctionType(asts.init.map(_.asInstanceOf[Type]), asts.last.asInstanceOf[Type]).fromAST(ast))

      case WildcardType(subType /*Type*/, superType /*Type*/) =>
        (subType :: superType :: Nil, asts => WildcardType(asts(0).asInstanceOf[Type], asts(1).asInstanceOf[Type]).fromAST(ast))

      case primitive : PrimitiveType => (Nil, asts => ast)

      case special @ (AnyType | BottomType) => (Nil, asts => ast)

      case TypeHint(hint /*String*/) => (Nil, asts => ast)

      case ComplexType(parents /*List[Type]*/, definitions /*List[Definition]*/, guard /*Expr*/) =>
        val sizes = ASTS(parents) :: ASTS(definitions) :: ASTS(guard :: Nil) :: HNil
        (parents ++ definitions :+ guard, asts => {
          val newParents :: newDefinitions :: List(newGuard) :: HNil = splits(asts, sizes)
          ComplexType(newParents, newDefinitions, newGuard).fromAST(ast)
        })

      // -- Expressions ---------

      case Ident(name /*String*/) => (Nil, asts => ast)

      case UnaryOp(operand /*Expr*/, operator /*String*/, postfix /*Boolean*/) =>
        (operand :: Nil, asts => UnaryOp(asts(0).asInstanceOf[Expr], operator, postfix).fromAST(ast))

      case BinaryOp(left /*Expr*/, operator /*String*/, right /*Expr*/) =>
        (left :: right :: Nil, asts => BinaryOp(asts(0).asInstanceOf[Expr], operator, asts(1).asInstanceOf[Expr]).fromAST(ast))

      case TernaryOp(cond /*Expr*/, thenn /*Expr*/, elze /*Expr*/) =>
        (cond :: thenn :: elze :: Nil,
          asts => TernaryOp(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Expr], asts(2).asInstanceOf[Expr]).fromAST(ast))

      case FunctionCall(receiver /*Expr*/, tparams /*List[Type]*/, args /*List[Expr]*/) =>
        val sizes = ASTS(receiver :: Nil) :: ASTS(tparams) :: ASTS(args) :: HNil
        ((receiver +: tparams) ++ args, asts => {
          val List(newReceiver) :: newTParams :: newArgs :: HNil = splits(asts, sizes)
          FunctionCall(newReceiver, newTParams, newArgs).fromAST(ast)
        })

      case ConstructorCall(tpe /*ClassType*/, args /*List[Expr]*/, body /*List[Definition]*/) =>
        val sizes = ASTS(tpe :: Nil) :: ASTS(args) :: ASTS(body) :: HNil
        ((tpe +: args) ++ body, asts => {
          val List(newTpe) :: newArgs :: newBody :: HNil = splits(asts, sizes)
          ConstructorCall(newTpe, newArgs, newBody).fromAST(ast)
        })

      case ArrayAccess(array /*Expr*/, index /*Expr*/) =>
        (array :: index :: Nil, asts => ArrayAccess(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Expr]).fromAST(ast))

      case ArrayLiteral(tpe /*Type*/, annotations /*List[Annotation]*/, dimensions /*List[Expr]*/, elements /*List[Expr]*/) =>
        val sizes = ASTS(tpe :: Nil) :: ASTS(annotations) :: ASTS(dimensions) :: ASTS(elements) :: HNil
        (tpe :: annotations ++ dimensions ++ elements, asts => {
          val List(newTpe) :: newAnnotations :: newDimensions :: newElements :: HNil = splits(asts, sizes)
          ArrayLiteral(newTpe, newAnnotations, newDimensions, newElements).fromAST(ast)
        })

      case MultiLiteral(elements /*List[Expr]*/) =>
        (elements, asts => MultiLiteral(asts.map(_.asInstanceOf[Expr])).fromAST(ast))

      case Assign(target /*Expr*/, value /*Expr*/, operator /*Option[String]*/) =>
        (target :: value :: Nil, asts => Assign(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Expr], operator).fromAST(ast))

      case Cast(expr /*Expr*/, tpe /*Type*/) =>
        (expr :: tpe :: Nil, asts => Cast(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Type]).fromAST(ast))

      case ClassAccess(tpe /*Type*/) =>
        (tpe :: Nil, asts => ClassAccess(asts(0).asInstanceOf[Type]).fromAST(ast))

      case MethodAccess(tpe /*Type*/, name /*String*/, tparams /*List[Type]*/) =>
        val sizes = ASTS(tpe :: Nil) :: ASTS(tparams) :: HNil
        (tpe :: tparams, asts => {
          val List(newTpe) :: newTParams :: HNil = splits(asts, sizes)
          MethodAccess(newTpe, name, newTParams).fromAST(ast)
        })

      case FieldAccess(receiver /*Expr*/, name /*String*/, tparams /*List[Type]*/) =>
        val sizes = ASTS(receiver :: Nil) :: ASTS(tparams) :: HNil
        (receiver :: tparams, asts => {
          val List(newReceiver) :: newTParams :: HNil = splits(asts, sizes)
          FieldAccess(newReceiver, name, newTParams).fromAST(ast)
        })

      case InstanceOf(expr /*Expr*/, tpe /*Type*/) =>
        (expr :: tpe :: Nil, asts => InstanceOf(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Type]).fromAST(ast))

      case SimpleLiteral(tpe /*PrimitiveType*/, value /*String*/) =>
        (tpe :: Nil, asts => SimpleLiteral(asts(0).asInstanceOf[PrimitiveType], value).fromAST(ast))

      case special @ (NullLiteral | VoidLiteral) => (Nil, asts => ast)

      case This(qualifier /*Expr*/) =>
        (qualifier :: Nil, asts => This(asts(0).asInstanceOf[Expr]).fromAST(ast))

      case Super(qualifier /*Expr*/) =>
        (qualifier :: Nil, asts => Super(asts(0).asInstanceOf[Expr]).fromAST(ast))

      case Annotation(name /*String*/, params /*Map[String, Expr]*/) =>
        val (names, expressions) = params.toList.unzip
        (expressions, asts => Annotation(name, (names zip asts.map(_.asInstanceOf[Expr])).toMap).fromAST(ast))

      case FunctionLiteral(params /*List[ValDef]*/, tpe /*Type*/, body /*Statement*/) =>
        val sizes = ASTS(params) :: ASTS(tpe :: Nil) :: ASTS(body :: Nil) :: HNil
        (params :+ tpe :+ body, asts => {
          val newParams :: List(newTpe) :: List(newBody) :: HNil = splits(asts, sizes)
          FunctionLiteral(newParams, newTpe, newBody).fromAST(ast)
        })

      case Wildcard => (Nil, asts => ast)

      case If(condition /*Expr*/, thenStatement /*Statement*/, elseStatement /*Statement*/) =>
        (condition :: thenStatement :: elseStatement :: Nil,
          asts => If(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Statement], asts(2).asInstanceOf[Statement]).fromAST(ast))

      case Switch(selector /*Expr*/, entries /*List[(Expr, Block)]*/) =>
        val (matchers, bodies) = entries.unzip
        val sizes = ASTS(selector :: Nil) :: ASTS(matchers) :: ASTS(bodies) :: HNil
        ((selector +: matchers) ++ bodies, asts => {
          val List(newSelector) :: newMatchers :: newBodies :: HNil = splits(asts, sizes)
          Switch(newSelector, newMatchers zip newBodies).fromAST(ast)
        })

      case Foreach(vals /*List[ValDef]*/, iterable /*Expr*/, body /*Statement*/, generator /*Boolean*/) =>
        val sizes = ASTS(vals) :: ASTS(iterable :: Nil) :: ASTS(body :: Nil) :: HNil
        (vals :+ iterable :+ body, asts => {
          val newVals :: List(newIterable) :: List(newBody) :: HNil = splits(asts, sizes)
          Foreach(newVals, newIterable, newBody, generator).fromAST(ast)
        })

      case Throw(expr /*Expr*/) =>
        (expr :: Nil, asts => Throw(asts(0).asInstanceOf[Expr]).fromAST(ast))

      case Try(tryBlock /*Block*/, catchs /*List[(ValDef, Block)]*/, finallyBlock /*Block*/) =>
        val (exceptions, bodies) = catchs.unzip
        val sizes = ASTS(tryBlock :: Nil) :: ASTS(exceptions) :: ASTS(bodies) :: ASTS(finallyBlock :: Nil) :: HNil
        ((tryBlock +: exceptions) ++ (bodies :+ finallyBlock), asts => {
          val List(newTry) :: newExceptions :: newBodies :: List(newFinally) :: HNil = splits(asts, sizes)
          Try(newTry, newExceptions zip newBodies, newFinally).fromAST(ast)
        })

      case Guarded(expr /*Expr*/, condition /*Expr*/) =>
        (expr :: condition :: Nil, asts => Guarded(asts(0).asInstanceOf[Expr], asts(1).asInstanceOf[Expr]).fromAST(ast))

      case Bind(name /*String*/, expr /*Expr*/) => (expr :: Nil, asts => Bind(name, asts(0).asInstanceOf[Expr]).fromAST(ast))

      case NoDef | NoType | NoExpr | NoStmt => (Nil, asts => ast)
    }
  }
}
